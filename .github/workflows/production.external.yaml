name: Deploy EXTERNAL Production
on:
  workflow_dispatch:
jobs:
  kubernetes:
    # Checkout the repository
    runs-on: [self-hosted]
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          lfs: true
          ref: main
      - name: Git LFS Checkout
        run: git lfs pull

      # Overwrites ${VARIABLES} in the kube manifest with secrets
      - shell: bash
        name: Manifest env substitute
        env:
          CI_REGISTRY: ${{ secrets.CI_REGISTRY }}
          CI_REGISTRY_PATH: ${{ secrets.CI_REGISTRY_PATH }}
          PRODUCTION_TAG_NUMBER: ${{ secrets.PRODUCTION_TAG_NUMBER }}
        run: |
          cd $GITHUB_WORKSPACE/kubernetes
          envsubst < production.external.yaml > manifest.yaml

      # Initializes the kube context, introducing kubectl to the cluster
      - uses: azure/k8s-set-context@v3
        name: Configure K8s
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}
          context: deploy-service-account

      # Deploys the kube manifest
      - uses: Azure/k8s-deploy@v4
        name: Deploy K8s Workload
        with:
          resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}
          name: ${{ secrets.AKS_CLUSTER_NAME }}
          namespace: npd-prd
          action: deploy
          force: true
          strategy: basic
          manifests: |
            kubernetes/manifest.yaml
  database:
    # Checkout the repository
    runs-on: [self-hosted]
    environment: production
    needs: kubernetes
    steps:
      # Initializes the kube context, introducing kubectl to the runner
      - uses: azure/k8s-set-context@v3
        name: Configure K8s
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}
          context: deploy-service-account

      # This script catches the PostGIS database pod name, and executes the psql script against it, loading the .sql dump
      - shell: bash
        name: Upload PostGIS data
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        run: |
          container=$(kubectl get pods --no-headers -o custom-columns=":metadata.name" --namespace npd-prd | grep npd-db)
          echo $container
          kubectl exec $container --namespace npd-prd -- sh -c "psql --quiet --user $POSTGRES_USER postgres < /data/npd/pg_dump.sql"
